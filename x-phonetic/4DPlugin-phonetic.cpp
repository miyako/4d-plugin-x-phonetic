/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-phonetic.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : phonetic
 #	author : miyako
 #	2020/06/02
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-phonetic.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- phonetic
                
            case 1 :
                Phonetic(params);
                break;
            case 2 :
                Phonetics(params);
                break;
                
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

#if VERSIONWIN

#define CLSID_VERSION_DEPENDENT_MSIME_JAPANESE OLESTR("{6a91029e-aa49-471b-aee7-7d332785660d}")
#define CLSID_MSIME_JAPANESE OLESTR("{af9ee286-8cd3-445e-8842-433e5c460775}")

static const IID IID_IFECommon = {
    0x19f7151, 0xe6db, 0x11d0,
    { 0x83, 0xc3, 0x00, 0xc0, 0x4f, 0xdd, 0xb8, 0x2e }
};

static const IID IID_IFELanguage = {
    0x019f7152, 0xe6db, 0x11d0,
    { 0x83, 0xc3, 0x00, 0xc0, 0x4f, 0xdd, 0xb8, 0x2e }
};

static const IID IID_IFELanguage2 = {
    0x21164102, 0xc24a, 0x11d1,
    { 0x85, 0x1a, 0x00, 0xc0, 0x4f, 0xcc, 0x6b, 0x14 }
};

static const IID IID_IFEDictionary = {
    0x19f7153, 0xe6db, 0x11d0,
    { 0x83, 0xc3, 0x0, 0xc0, 0x4f, 0xdd, 0xb8, 0x2e }
};

#endif

void Phonetic(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    
#if VERSIONMAC
    NSString *sourceText = Param1.copyUTF16String();
    NSMutableString *outputTextHiragana = [[NSMutableString alloc]init];
    CFLocaleRef locale = CFLocaleCopyCurrent();
    CFRange range = CFRangeMake(0, [sourceText length]);
    
    CFStringTokenizerRef tokenizer = CFStringTokenizerCreate(kCFAllocatorDefault,
                                                             (CFStringRef)sourceText,
                                                             range,
                                                             kCFStringTokenizerUnitWordBoundary,
                                                             locale);
    CFStringTokenizerTokenType tokenType = CFStringTokenizerGoToTokenAtIndex(tokenizer, 0);
    while (tokenType != kCFStringTokenizerTokenNone)
    {
        range = CFStringTokenizerGetCurrentTokenRange(tokenizer);
        CFTypeRef latinTranscription = CFStringTokenizerCopyCurrentTokenAttribute(tokenizer, kCFStringTokenizerAttributeLatinTranscription);
        if(latinTranscription)
        {
            NSMutableString *hiragana = [(NSString *)latinTranscription mutableCopy];
            CFStringTransform((CFMutableStringRef)hiragana, NULL, kCFStringTransformLatinHiragana, false);
            CFRelease(latinTranscription);
            [outputTextHiragana appendString:hiragana];
            [hiragana release];
        }
        tokenType = CFStringTokenizerAdvanceToNextToken(tokenizer);
    }
    CFRelease(tokenizer);
    CFRelease(locale);
    
    returnValue.setUTF16String(outputTextHiragana);
    [outputTextHiragana release];
    [sourceText release];
    
#else
    
    IFELanguage *ifelang = NULL;
    CLSID clsid;
    
    if(S_OK == CLSIDFromProgID(szImeJapan, &clsid)) {
        
        if(S_OK == CoCreateInstance(clsid,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IFELanguage,
                                    reinterpret_cast<void**>(&ifelang))) {
            if(ifelang) {
                if(S_OK == ifelang->Open()) {
                    BSTR sourceText = SysAllocString((const wchar_t *)Param1.getUTF16StringPtr());
                    BSTR phonetic;
                    
                    if (S_OK == ifelang->GetPhonetic(sourceText, 1, -1, &phonetic)) {
                        returnValue.setUTF16String((const PA_Unichar *)phonetic, SysStringLen(phonetic));
                        SysFreeString(phonetic);
                    }
                    
                    SysFreeString(sourceText);
                }
                ifelang->Close();
                ifelang->Release();
            }
        }
    }
#endif
    
    returnValue.setReturn(pResult);
    
}

typedef enum {
    
    phonetic_mode_detail    = 0,
    phonetic_mode_simple    = 1,
    phonetic_mode_lexical    = 2,
    phonetic_mode_multiple    = 3
    
}phonetic_mode_t;

typedef enum {
    
    phonetic_format_hiragana = 0,
    phonetic_format_katakana = 1
    
}phonetic_format_t;

typedef enum {
    
    phonetic_width_full = 0,
    phonetic_width_half = 1
    
}phonetic_width_t;


void Phonetics(PA_PluginParameters params) {
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    
    phonetic_mode_t mode = phonetic_mode_simple;
    phonetic_format_t format = phonetic_format_hiragana;
    phonetic_width_t width = phonetic_width_full;
    
    if(options) {
        
        CUTF8String _width;
        if (ob_is_defined(options, L"width")) {
            if (ob_get_s(options, L"width", &_width)) {
                
                if (_width == (const uint8_t *)"full") {
                    width = phonetic_width_full;
                }
                
                if (_width == (const uint8_t *)"half") {
                    width = phonetic_width_half;
                }
                
            }
            
        }
        
        CUTF8String _mode;
        if(ob_is_defined(options, L"mode")) {
            if(ob_get_s(options, L"mode", &_mode)) {
                
                if(_mode == (const uint8_t *)"simple") {
                    mode = phonetic_mode_simple;
                }
                
                if(_mode == (const uint8_t *)"detail") {
                    mode = phonetic_mode_detail;
                }
                
                if(_mode == (const uint8_t *)"lexical") {
                    mode = phonetic_mode_lexical;
                }
 
            }
            
        }
        
        CUTF8String _format;
        if (ob_is_defined(options, L"format")) {
            if (ob_get_s(options, L"format", &_format)) {
                
                if (_format == (const uint8_t *)"hiragana") {
                    format = phonetic_format_hiragana;
                }
                
                if (_format == (const uint8_t *)"katakana") {
                    format = phonetic_format_katakana;
                }
                
            }
            
        }
        
    }
    
    C_TEXT Param1;
    PA_CollectionRef returnValues = PA_CreateCollection();
    
    Param1.fromParamAtIndex(pParams, 1);
    
#if VERSIONMAC
    
    NSString *sourceText = Param1.copyUTF16String();

    if(mode != phonetic_mode_lexical) {
        
           CFLocaleRef locale = CFLocaleCopyCurrent();
           CFRange range = CFRangeMake(0, [sourceText length]);
           
           CFStringTokenizerRef tokenizer = CFStringTokenizerCreate(kCFAllocatorDefault,
                                                                    (CFStringRef)sourceText,
                                                                    range,
                                                                    kCFStringTokenizerUnitWordBoundary,
                                                                    locale);
           
           CFStringTokenizerTokenType tokenType = CFStringTokenizerGoToTokenAtIndex(tokenizer, 0);
           
           while (tokenType != kCFStringTokenizerTokenNone)
           {
               range = CFStringTokenizerGetCurrentTokenRange(tokenizer);
                       
               CFTypeRef latinTranscription = CFStringTokenizerCopyCurrentTokenAttribute(tokenizer, kCFStringTokenizerAttributeLatinTranscription);
               if(latinTranscription)
               {
                   PA_ObjectRef word = PA_CreateObject();
                   
                   C_TEXT t;
                   CUTF16String u16;
                   
                   t.setUTF16String([sourceText substringWithRange:NSMakeRange(range.location, range.length)]);
                   t.copyUTF16String(&u16);
                   ob_set_a(word, L"word", &u16);
                   
                   NSMutableString *outputText = [(NSString *)latinTranscription mutableCopy];
                   CFStringTransform((CFMutableStringRef)outputText, NULL, kCFStringTransformLatinHiragana, false);
                   
                   if (format == phonetic_format_katakana) {
                       CFStringTransform((CFMutableStringRef)outputText,
                       NULL,
                       CFSTR("[:^Modifier Letter:];Hiragana-Katakana"),
                       false);
                   }
                   if (width == phonetic_width_half) {
                       CFStringTransform((CFMutableStringRef)outputText,
                       NULL,
                       kCFStringTransformFullwidthHalfwidth,
                       false);
                   }
                   
                   t.setUTF16String(outputText);
                   t.copyUTF16String(&u16);
                   ob_set_a(word, L"yomi", &u16);
        
                   [outputText release];
                   
                   PA_Variable v = PA_CreateVariable(eVK_Object);
                   PA_SetObjectVariable(&v, word);
                   PA_SetCollectionElement(returnValues, PA_GetCollectionLength(returnValues), v);
                   PA_ClearVariable(&v);
                   
                   CFRelease(latinTranscription);
               }
               tokenType = CFStringTokenizerAdvanceToNextToken(tokenizer);
           }
           CFRelease(tokenizer);
           CFRelease(locale);
    }
            
    if(mode == phonetic_mode_lexical) {
        
        /* ja: Language, Script, TokenType
         NSLinguisticTagSchemeLexicalClass is not available for ja!
         */
        /* en: all 7 types */
        
        NSArray<NSLinguisticTagScheme> *tagSchemes = [NSLinguisticTagger availableTagSchemesForLanguage:@"en"];
        
        NSLinguisticTagger *tagger = [[NSLinguisticTagger alloc]initWithTagSchemes:tagSchemes options:0];
        
        if(tagger) {
            
            tagger.string = sourceText;
            
            [tagger
             enumerateTagsInRange:NSMakeRange(0, [sourceText length])
             scheme:NSLinguisticTagSchemeLexicalClass
             options:NSLinguisticTaggerOmitWhitespace
             usingBlock:^(NSLinguisticTag tag, NSRange tokenRange, NSRange sentenceRange, BOOL *stop){
                
                PA_ObjectRef word = PA_CreateObject();
                
                C_TEXT t;
                CUTF16String u16;
                
                t.setUTF16String([sourceText substringWithRange:tokenRange]);
                t.copyUTF16String(&u16);
                ob_set_a(word, L"word", &u16);
                
                t.setUTF16String(tag);
                t.copyUTF16String(&u16);
                ob_set_a(word, L"tag", &u16);
                
                PA_Variable v = PA_CreateVariable(eVK_Object);
                PA_SetObjectVariable(&v, word);
                PA_SetCollectionElement(returnValues, PA_GetCollectionLength(returnValues), v);
                PA_ClearVariable(&v);
                
            }];
            
            [tagger release];
        }
        
    }
    
    [sourceText release];
    
#else
    
    IFELanguage *ifelang = NULL;
    CLSID clsid;
    
    if(S_OK == CLSIDFromProgID(szImeJapan, &clsid)) {
        
        if (S_OK == CoCreateInstance(clsid,
                                     NULL,
                                     CLSCTX_INPROC_SERVER,
                                     IID_IFELanguage,
                                     reinterpret_cast<void**>(&ifelang))) {
            
            if(ifelang) {
                if(S_OK == ifelang->Open()) {
                    
                    DWORD dwCaps = 0;
                    
                    if (S_OK == ifelang->GetConversionModeCaps(&dwCaps)) {
                        
                    }
                    
                    DWORD dwRequest = FELANG_REQ_REV;
                    DWORD dwCMode = 0;
                    
                    dwCMode |= FELANG_CMODE_NOPRUNING;
                    dwCMode |= FELANG_CMODE_MERGECAND;
                    
                    //dwCMode |= FELANG_CMODE_MONORUBY;
                    
                    if (width == phonetic_width_full) {
                        dwCMode |= FELANG_CMODE_FULLWIDTHOUT;
                    }
                    
                    if (width == phonetic_width_half) {
                        dwCMode |= FELANG_CMODE_HALFWIDTHOUT;
                    }
                    
                    if (format == phonetic_format_katakana) {
                        dwCMode |= FELANG_CMODE_KATAKANAOUT;
                    }
                    
                    if (format == phonetic_format_hiragana) {
                        dwCMode |= FELANG_CMODE_HIRAGANAOUT;
                    }
                    
                    dwCMode |= FELANG_CMODE_SINGLECONVERT;
                    
                    //dwCMode |= FELANG_CMODE_PRECONV;
                    //dwCMode |= FELANG_CMODE_BESTFIRST;
                    
                    dwCMode |= FELANG_CMODE_USENOREVWORDS;
                    
                    dwCMode |= FELANG_CMODE_NONE;
                    dwCMode |= FELANG_CMODE_PLAURALCLAUSE;
                    dwCMode |= FELANG_CMODE_SINGLECONVERT;
                    dwCMode |= FELANG_CMODE_AUTOMATIC;
                    dwCMode |= FELANG_CMODE_PHRASEPREDICT;
                    dwCMode |= FELANG_CMODE_CONVERSATION;
                    dwCMode |= FELANG_CMODE_NAME;
                    
                    INT cwchInput = Param1.getUTF16Length();
                    WCHAR *pwchInput = (WCHAR *)Param1.getUTF16StringPtr();
                    
                    std::vector<DWORD>pfCInfo(cwchInput);
                    
                    for (size_t i = 0; i < cwchInput; ++i) {
                        pfCInfo[i] = FELANG_CLMN_NOPBREAK;
                    }
                    
                    MORRSLT *pResult = NULL;
                    
                    HRESULT status = S_FALSE;
                    
                    PA_CollectionRef returnValue;
                    
                    if(mode == phonetic_mode_multiple) {
                        returnValue = PA_CreateCollection();
                    }

                    do
                    {
                        status = ifelang->GetJMorphResult(dwRequest,
                                                          dwCMode,
                                                          cwchInput,
                                                          pwchInput,
                                                          &pfCInfo[0],
                                                          &pResult);
                        
                        if (status == S_OK) {
                            
                                WDD *pWDD = pResult->pWDD;
                                
                                for (int i = 0; i < pResult->cWDD; ++i) {
                                    
                                    WDD wdd = pWDD[i];
                                    
                                    PA_ObjectRef morph = PA_CreateObject();
                                    
                                    CUTF16String word = CUTF16String((const PA_Unichar *)&pResult->pwchRead[wdd.wReadPos], wdd.cchRead);
                                    CUTF16String yomi = CUTF16String((const PA_Unichar *)&pResult->pwchOutput[wdd.wDispPos], wdd.cchDisp);
                                    
                                    ob_set_a(morph, L"word", &word);
                                    ob_set_a(morph, L"yomi", &yomi);
                                    
									if (mode != phonetic_mode_simple) {
										ob_set_n(morph, L"partOfSpeech", wdd.nPos);
										ob_set_b(morph, L"isStartOfPhrase", wdd.fPhrase);
										ob_set_b(morph, L"isAutoCorrect", wdd.fAutoCorrect);
										ob_set_b(morph, L"isNumericPrefix", wdd.fNumericPrefix);
										ob_set_b(morph, L"isUserRegistered", wdd.fUserRegistered);
										ob_set_b(morph, L"isUnknown", wdd.fUnknown);
										ob_set_b(morph, L"isRecentUsed", wdd.fRecentUsed);
									}

                                    PA_Variable v = PA_CreateVariable(eVK_Object);
                                    PA_SetObjectVariable(&v, morph);
                                    
                                    if(mode == phonetic_mode_multiple) {
                                        PA_SetCollectionElement(returnValue, PA_GetCollectionLength(returnValue), v);
                                    }else{
                                        PA_SetCollectionElement(returnValues, PA_GetCollectionLength(returnValues), v);
                                    }
                                    
                                    PA_ClearVariable(&v);
                                    
                                }
                            
                            CoTaskMemFree(pResult);
                            pResult = NULL;
                            cwchInput = 0;
                            
                            if(mode == phonetic_mode_multiple) {
                                pwchInput = NULL;
                            }else{
                                pwchInput = L"";
                            }
                            
                        }
                        
                    } while (status == S_OK);
                    
                    if(mode == phonetic_mode_multiple) {
                        PA_Variable v = PA_CreateVariable(eVK_Collection);
                        PA_SetCollectionVariable(&v, returnValue);
                        PA_SetCollectionElement(returnValues, PA_GetCollectionLength(returnValues), v);
                        PA_ClearVariable(&v);
                    }
  
                }
                ifelang->Close();
                ifelang->Release();
            }
        }
    }
#endif
    
    PA_ReturnCollection(params, returnValues);
}
